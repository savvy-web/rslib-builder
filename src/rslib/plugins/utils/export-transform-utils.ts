import type { FlexibleExports } from "#utils/package-json-types-utils.js";
import { createTypePath, transformExportPath } from "#utils/path-transform-utils.js";

/**
 * Transforms string-based export values with special handling for TypeScript files.
 *
 * @remarks
 * This function processes individual export paths that are defined as strings in the
 * package.json exports field. It applies several transformations:
 *
 * 1. **Path Transformation**: Uses transformExportPath to update file paths
 * 2. **Type Generation**: Creates export conditions with both types and import fields for TypeScript files
 *
 * When processing TypeScript files, it generates an export conditions object that includes
 * both the JavaScript output and its TypeScript declarations, following modern package.json
 * standards for dual exports.
 *
 * @param exportString - The export path as a string
 * @param processTSExports - Whether to process TypeScript files and generate type conditions
 * @param exportKey - The export key from package.json (used for entrypoints mapping)
 * @returns Transformed export value (string or conditions object)
 *
 * @example
 * ```typescript
 * // Regular TypeScript file - generates conditions object
 * transformStringExport("./src/index.ts", true);
 * // Result: { types: "./index.d.ts", import: "./index.js" }
 *
 * // JavaScript file - simple transformation
 * transformStringExport("./src/utils.js", true);
 * // Result: "./utils.js"
 *
 * // TypeScript processing disabled
 * transformStringExport("./src/index.ts", false);
 * // Result: "./index.ts"
 * ```
 */
export function transformStringExport(
	exportString: string,
	processTSExports: boolean,
	exportKey?: string,
	entrypoints?: Map<string, string>,
	exportToOutputMap?: Map<string, string>,
	collapseIndex: boolean = false,
): FlexibleExports {
	// First, check if we have a direct mapping from export key to output path (for exportsAsIndexes)
	let transformedPath: string;
	if (exportToOutputMap && exportKey && exportToOutputMap.has(exportKey)) {
		// Use the mapped output path for exportsAsIndexes
		const mappedPath = exportToOutputMap.get(exportKey);
		if (!mappedPath) {
			throw new Error(`Export key "${exportKey}" has no mapped path`);
		}
		transformedPath = mappedPath;
	} else if (entrypoints && exportKey) {
		// Check if entrypoints map has an updated path for this export key
		// This handles cases where JsonSchemaPlugin has updated the entrypoints
		// Try the export key with and without the "./" prefix since entry extractor removes it
		const keyWithoutPrefix = exportKey.startsWith("./") ? exportKey.slice(2) : exportKey;
		if (entrypoints.has(exportKey)) {
			// Use the updated path from entrypoints (e.g., JSON file generated by JsonSchemaPlugin)
			transformedPath = entrypoints.get(exportKey) ?? exportString;
		} else if (entrypoints.has(keyWithoutPrefix)) {
			// Try without the "./" prefix
			transformedPath = entrypoints.get(keyWithoutPrefix) ?? exportString;
		} else {
			// Fall back to normal path transformation
			transformedPath = transformExportPath(exportString, processTSExports, collapseIndex);
		}
	} else {
		// Fall back to normal path transformation
		transformedPath = transformExportPath(exportString, processTSExports, collapseIndex);
	}

	// RSLib always generates types for TypeScript source files when processTSExports is true
	// Create an object with types and import key for .ts/.tsx files (excluding .d.ts files)
	if (
		processTSExports &&
		(exportString.endsWith(".ts") || exportString.endsWith(".tsx")) &&
		!exportString.endsWith(".d.ts")
	) {
		return {
			types: createTypePath(transformedPath, collapseIndex),
			import: transformedPath,
		};
	}

	return transformedPath;
}

/**
 * Transforms array-based exports by recursively processing each item.
 *
 * @remarks
 * Array exports are used in package.json to provide fallback mechanisms where the first
 * supported export format is used. This function processes each item in the array,
 * applying the same transformation logic used for other export types.
 *
 * @param exportsArray - Array of export values to transform
 * @param processTSExports - Whether to process TypeScript files
 * @param exportKey - The export key from package.json
 * @returns Array of transformed export values
 *
 * @example
 * ```typescript
 * transformArrayExports([
 *   "./src/modern.ts",
 *   "./src/fallback.js"
 * ], true);
 * // Result: [
 * //   { types: "./modern.d.ts", import: "./modern.js" },
 * //   "./fallback.js"
 * // ]
 * ```
 */
export function transformArrayExports(
	exportsArray: FlexibleExports[],
	processTSExports: boolean,
	exportKey?: string,
	entrypoints?: Map<string, string>,
	exportToOutputMap?: Map<string, string>,
	collapseIndex: boolean = false,
): FlexibleExports[] {
	return exportsArray.map((item) => {
		const transformed = transformPackageExports(
			item,
			processTSExports,
			exportKey,
			entrypoints,
			exportToOutputMap,
			collapseIndex,
		);
		return transformed ?? item;
	});
}

/**
 * Determines if an export object represents export conditions rather than subpath exports.
 *
 * @remarks
 * Export conditions (import, require, types, default) define different resolution paths
 * for the same export based on how it's being imported. Subpath exports define different
 * entry points within a package. This distinction is important for proper transformation.
 *
 * Standard condition keys include:
 * - `import`: ES module format
 * - `require`: CommonJS format
 * - `types`: TypeScript declarations
 * - `default`: Fallback condition
 *
 * @param exports - Export object to check
 * @returns True if the object contains export conditions, false for subpath exports
 *
 * @example
 * ```typescript
 * // Conditions object
 * isConditionsObject({
 *   import: "./index.js",
 *   require: "./index.cjs",
 *   types: "./index.d.ts"
 * }); // true
 *
 * // Subpath exports
 * isConditionsObject({
 *   "./utils": "./src/utils.js",
 *   "./helpers": "./src/helpers.js"
 * }); // false
 * ```
 */
export function isConditionsObject(exports: Record<string, unknown>): boolean {
	return Object.keys(exports).some(
		(key) => key === "import" || key === "require" || key === "types" || key === "default",
	);
}

/**
 * Transforms a single export entry (key-value pair) based on whether it's a condition or subpath.
 *
 * @remarks
 * This function handles the transformation of individual entries within export objects,
 * applying different logic based on whether the entry represents an export condition
 * (like "import" or "types") or a subpath export (like "./utils").
 *
 * @param key - The export key
 * @param value - The export value
 * @param isConditions - Whether this is part of a conditions object
 * @param processTSExports - Whether to process TypeScript files
 * @param exportKey - The parent export key for context
 * @returns The transformed export value
 */
export function transformExportEntry(
	key: string,
	value: unknown,
	isConditions: boolean,
	processTSExports: boolean,
	exportKey?: string,
	entrypoints?: Map<string, string>,
	exportToOutputMap?: Map<string, string>,
	collapseIndex: boolean = false,
): unknown {
	if (isConditions && (key === "import" || key === "require" || key === "types" || key === "default")) {
		// For existing export conditions, just transform the path
		if (typeof value === "string") {
			return transformExportPath(value, processTSExports, collapseIndex);
		}
		if (value !== undefined && value !== null) {
			return transformPackageExports(
				value as FlexibleExports,
				processTSExports,
				exportKey,
				entrypoints,
				exportToOutputMap,
				collapseIndex,
			);
		}
		return value; // Keep undefined/null as-is
	}

	// For export subpaths, recursively transform (pass the key as exportKey for subpaths)
	if (value !== undefined && value !== null) {
		return transformPackageExports(
			value as FlexibleExports,
			processTSExports,
			key,
			entrypoints,
			exportToOutputMap,
			collapseIndex,
		);
	}
	return value; // Keep undefined/null as-is
}

/**
 * Transforms object exports by processing each entry appropriately.
 *
 * @remarks
 * This function processes export objects, determining whether they represent export
 * conditions or subpath exports, and applying the appropriate transformation logic
 * to each entry.
 *
 * @param exportsObject - The export object to transform
 * @param processTSExports - Whether to process TypeScript files
 * @param exportKey - The export key for context
 * @returns The transformed export object
 */
export function transformObjectExports(
	exportsObject: Record<string, unknown>,
	processTSExports: boolean,
	exportKey?: string,
	entrypoints?: Map<string, string>,
	exportToOutputMap?: Map<string, string>,
	collapseIndex: boolean = false,
): Record<string, unknown> {
	const transformed: Record<string, unknown> = {};
	const isConditions = isConditionsObject(exportsObject);

	for (const [key, value] of Object.entries(exportsObject)) {
		transformed[key] = transformExportEntry(
			key,
			value,
			isConditions,
			processTSExports,
			exportKey,
			entrypoints,
			exportToOutputMap,
			collapseIndex,
		);
	}

	return transformed;
}

/**
 * Recursively transforms package.json exports field.
 *
 * @remarks
 * This is the main entry point for export transformations. It handles all export formats:
 * - String exports
 * - Array exports (fallbacks)
 * - Object exports (conditions and subpaths)
 * - Nested structures
 *
 * RSLib automatically generates type definitions, so TypeScript files are processed
 * to include both JavaScript output and type declaration references.
 *
 * @param exports - The exports value to transform
 * @param processTSExports - Whether to process TypeScript file extensions
 * @param exportKey - The export key for context
 * @returns The transformed exports value
 *
 * @example
 * ```typescript
 * // String export
 * transformPackageExports("./src/index.ts", true);
 * // Result: { types: "./index.d.ts", import: "./index.js" }
 *
 * // Object with conditions
 * transformPackageExports({
 *   import: "./src/index.ts",
 *   require: "./src/index.cjs"
 * }, true);
 * // Result: {
 * //   import: "./index.js",
 * //   require: "./index.cjs"
 * // }
 * ```
 */
export function transformPackageExports(
	exports: FlexibleExports,
	processTSExports: boolean = true,
	exportKey?: string,
	entrypoints?: Map<string, string>,
	exportToOutputMap?: Map<string, string>,
	collapseIndex: boolean = false,
): FlexibleExports {
	// Handle string exports
	if (typeof exports === "string") {
		return transformStringExport(exports, processTSExports, exportKey, entrypoints, exportToOutputMap, collapseIndex);
	}

	// Handle array exports
	if (Array.isArray(exports)) {
		return transformArrayExports(exports, processTSExports, exportKey, entrypoints, exportToOutputMap, collapseIndex);
	}

	// Handle object exports
	if (exports && typeof exports === "object") {
		return transformObjectExports(exports, processTSExports, exportKey, entrypoints, exportToOutputMap, collapseIndex);
	}

	// Return as-is for null, undefined, or other types
	/* v8 ignore next -- @preserve */
	return exports;
}
